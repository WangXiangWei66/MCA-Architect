# 操作系统

## 一、基础概念篇

### OS概念

- 什么是操作系统？

	- 操作系统（Operating System），简称OS
是管理计算机『硬件』与『软件』资源的计算机程序

	- 主要作用

		- 管理系统资源

			- 管理与配置内存

			- 决定系统资源供需的优先次序

			- 控制输入设备与输出设备

			- 管理文件系统等基本事务

		- 提供用户接口

			- 程序接口

			- 命令接口

			- GUI

		- 扩充机器

			- 实现了对硬件资源的抽象

		- 操作网络

- 什么是系统软件？

	- 特点

		- 与硬件交互

		- 对资源共享进行调度管理

		- 解决并发操作处理中存在的协调问题

		- 数据结构复杂，外部接口多样化，便于用户反复使用

	- 常见的系统软件

		- 电脑端

		- 手机端

		- 数据库

		- 各种编译程序/虚拟机等

- 操作系统的主要功能？

- 操作系统的（内核）结构？

	- 微内核

		- 系统服务与核心功能分离

			- 系统服务

				- 系统调用

				- 存储服务

				- 文件服务

			- 核心功能

				- 进程通信/调度

				- 低级存储器管理

				- 中断和陷入管理

		- Windows最初设计微内核，后来改成混合内核

	- 大内核/宏内核/混合内核

		- Linux是大内核

		- Mac OS是混合内核

		- 鸿蒙是混合内核？

- 什么是分时系统/实时系统？

	- 分时

		- 每个用户轮流使用一段时间

		- 轮流为每个用户分配固定时间片

		- 依次为用户服务

		- 及时性

			- 响应时间 1~3秒

	- 实时

		- 实时控制，实时信息处理

		- 轮流为每个用户分配随机时间片

		- 随机为用户服务

		- 实时性

			- 响应时间 毫秒级

- 什么是分布式操作系统？

	- 分布性

	- 并行性

### 内核

- 什么是内核？

	- 操作系统的核心功能放在内核里

	- 负责管理处理机、存储器、文件、IO设备等资源

- 什么是用户空间与内核空间？

	- 应用程序和非系统功能运行在用户空间

	- OS核心功能运行在内核空间

- 什么是用户态与内核态？

	- CPU的运行模式/操作系统的状态

	- 执行用户空间进程处于用户态/目态

	- 执行OS核心功能进程处于内核态/核心态/系统态/管态

- 用户态与内核态是怎么切换的？

	- CPU内部有一个小开关：程序状态字

	- 值为0，CPU处于核心态，执行内核程序

	- 值为1，CPU处于用户态，执行用户程序

### 中断

- 什么是中断？

	- 运行中出现意外，机器自动停止并处理，完毕后返回原程序继续运行的一种机制

	- 提高多道程序运行环境中CPU的利用率

	- OS运行的底层依赖机制之一

- 中断的分类？

	- 外中断/硬中断

		- 时钟中断

		- IO中断

	- 内中断/软中断，又叫异常

		- 陷入/陷阱/例外（Trap）：由应用程序主动引发

		- 故障（fault）：由错误条件引发

		- 终止（abort）：由致命错误引发

- 中断的处理过程？

	- 1.关中断

	- 2.保存断点

	- 3.引出中断服务程序

	- 4.保存现场和屏蔽字

	- 5.开中断

	- 6.执行中断服务程序

	- 7.关中断

	- 8.恢复现场和屏蔽字

	- 9.开中断，中断返回

### 原语

- 有没有听说过原语（primitive）？

	- 是一个程序段，运行在内核空间

	- 由若干条指令组成

	- 用来完成某个特定功能

	- 执行过程不会被中断

	- 在管态下执行， 常驻内存

	- 实现进程的通信和控制

- 常见的原语有哪些？

	- 进程创建：create()

- 什么是原子操作？

	- 执行过程中不会被中断的一系列操作

	- 可以包含多个操作，也可以是单个操作

### 系统调用

- 什么是系统调用？

	- 概念

		- 由操作系统实现

		- 提供给应用程序调用

		- 用以访问内核功能

		- 所有接口的集合

	- 命令分类

		- 设备管理

			- 完成设备的请求或释放，以及设备启动等功能

		- 文件管理

			- 完成文件的读、写、创建及删除等功能

		- 进程控制

			- 完成进程的创建、撤销、阻塞及唤醒等功能

		- 进程通信

			- 完成进程之间的消息传递或信号传递等功能

		- 内存管理

			- 完成内存的分配、回收以及获取作业占用内存区大小及始址等功能

- 什么是陷入/访管指令？

	- 应用程序尝试进行系统调用的时候触发的

	- 是CPU产生的，不是给用户直接调用的隐指令

- 怎么理解特权指令？

	- 内核空间的程序指令

## 二、进程篇

### 概念相关

- 进程与线程

	- 什么是进程？

		- 进程（Process），是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行『资源分配和调度』的一个独立单位

			- 进，即行进，程，即程序，顾名思义，运行着的程序叫做进程。通俗的说，一个进程就是一个运行着的应用程序。

		- 几个要点

			- （1） 进程是『程序』的『一次执行』

				- 每一个进程都是一个独立功能的应用程序，该程序执行起来之后，才叫做进程；
若该程序被执行多次，就会产生多个进程

				- 进程是正在运行的程序的实例（an instance of a computer program that is being executed）

			- （2） 进程是一个程序及其数据在处理机上顺序执行时所发生的『活动』

				- 进程是一次运行活动，指的是，进程是处于运行状态的应用程序，即所谓“活动的实体”，如果某个应用程序没有运行，它不是一个进程

				- 没有运行的程序称为静态实体(Passive Entity)，比如磁盘上的eclipse应用程序：

			- （3）进程是程序在一个『数据集合』上运行的过程

				- 进程是一个实体，它有自己的独立的地址空间，用于存储代码、变量和指令等等，称之为“数据集合”

			- （4）进程是系统进行『资源分配和调度』的一个『独立』单位（或者说基本单位）

				- 操作系统以进程为基本单位进行分配资源

				- 每个进程独立运行，独立调度

	- 什么是线程？

		- 线程（Thread），也叫“轻量级进程”，是一系列活动按事先设定好的顺序依次执行的过程，是一系列指令的集合

		- 线程是进程中一条执行路径，它不能单独存在，必须包含在进程中，一个进程可以有多个线程

		- 线程是OS进行运算调度的最小单位

	- 进程和线程的区别？

		- 1）调度

			- 在多线程OS中，线程是独立调度的基本单位，进程是资源分配的基本单位

			- 同一进程中切换线程，不会引起进程切换

		- 2）拥有资源

			- 进程拥有资源，而线程（一般）不拥有资源，这样做是为了减少切换线程的开销

			- 同一个进程中的多个线程共享该进程的资源

		- 3）并发性

			- 在多线程OS中，进程可以并发执行，线程也可以并发执行，线程的并发大大提高了OS的并发性

		- 4）系统开销

			- 创建和撤销进程，需要分配和回收相关资源，开销较大；切换进程的成本较高

			- 相对而言，创建和切换线程的成本较低，只需要保存少量寄存器内容，开销小

		- 5）地址空间和其它资源

			- 进程间的地址空间相互独立

			- 同一进程的线程间共享进程资源，进程间的线程彼此不可见

		- 6）通信方面

			- 进程通信需要同步或互斥手段的辅助

			- 线程间可以直接读写数据段（如全局变量）来通信

			- 同一进程内的线程共享该进程资源，同步和通信都更容易实现

		- 总结

			- 进程

				-  (1) 作为系统『资源分配』的基本单位 

				- (2) 可包括多个线程，至少有一个线程 

				- (3) 进程不是一个可执行的实体，真正执行的是线程

			- 线程

				- 是独立运行和独立调度的基本单位

			- 引入进程的目的在于，使多道程序并发执行，提高系统的资源利用率和吞吐量

			- 而引入线程，是为了减少程序在并发时的时空开销，提高系统的并发性

				- 相对于进程，大大降低了创建、撤销和切换可执行实体的成本和难度

	- 什么是协程/纤程？

		- 一个线程可以有多个协程

		- 函数级的调度，不被内核管理，而是程序控制

		- 非抢占式，需主动释放执行权（yield），然后其它协程执行（相当于单线程能力）

		- 能保留上一次执行状态

		- Python、Go

- 并发与并行

	- 什么是并发？

		- 『同一时间段』（同一时间间隔）内执行和调度多个程序的能力

			- 伴随着“多道程序技术”，操作系统添加了多处理器协调功能，并发、并行由此而生

		- 特点

			- 宏观上看，处理机在同时执行多道程序

			- 微观上看，处理机在多道程序之间高速切换（分时交替执行）

	- 什么是并行？

		- 『同一时间点』上执行和调度多个程序的能力

	- 并发与并行的区别？

		- 并发：关注单CPU同时执行多任务（在多任务间高速切换）的能力

		- 并行：关注有多少个CPU可以同时执行任务的能力

- 进程的状态？

	- 什么是进程的生命周期？

	- 三个基本状态？

		- 1) 就绪（Ready）

			- 进程已分配到除CPU以外的所有必要资源后， 只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态

			- 可运行未运行状态

			- 多个处于就绪状态的进程会形成一个就绪队列

		- 2) 执行（Running）

			- 进程已获得CPU（执行权）， 其程序正在执行

			- 在单处理机系统中，只有一个进程处于执行状态；
 在多处理机系统中，则有多个进程处于执行状态

		- 3) 阻塞（Blocked）

			- 正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，即阻塞

			- 也称为等待状态或封锁状态

			- 发生阻塞的典型事件

				- 请求I/O

				- 申请缓冲空间

				- 进程同步

			- 阻塞状态的进程也会排成一个队列，由于不同原因导致的阻塞，可以会形成多个队列

	- 各状态怎么转换/状态模型？

		- (1) NULL→创建： 一个新进程产生时，该进程处于创建状态

		- (2) 创建→活动就绪：在当前系统的性能和内存的容量均允许的情况下， 完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态

		- (3) 创建→静止就绪：考虑到系统当前资源状况和性能要求， 并不分配给新建进程所需资源， 主要是主存资源，相应的系统进程将进程状态转为静止就绪状态，对换到外存， 不再参与调度， 此时进程创建工作尚未完成

		- (4) 执行→终止： 当一个进程到 了自然结束点 一个进程到达了自然结束点， 或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结， 进程即进终止状态

- 什么叫用户线程/内核线程？

	- 用户级线程
（User-Level Thread, ULT）

		- 线程管理工作由应用程序完成

		- 内核感受不到用户线程的存在

		- 在应用程序中通过线程库创建新的线程

	- 内核级线程
（Kernel-Level Thread，KLT）

		- 线程管理工作由内核完成，由内核的内部需求进行创建和撤销

		- 应用程序可以通过一个内核级线程的编程接口访问内核线程

		- 内核为进程及其内部线程维护上下文信息，需要内核的参与来完成线程的调度

- OS的多线程模型？

	- 有些OS同时支持用户级线程和内核级线程，实现了二者的组合连接方式

	- 多对一模型

		- 多个用户级线程 -> 一个内核级线程

		- 线程管理在用户空间进行，高效

		- 若一个用户线程使用内核服务时阻塞，则整个进程阻塞

	- 一对一模型

		- 每个用户级线程 -> 一个内核级线程

		- 并发能力较强，一个线程阻塞不影响其它线程

		- 内核线程创建较多，影响性能

	- 多对多模型

		- n个用户级线程 -> m个内核级线程，m <= n

		- 克服了多对一模型并发度不高的缺点

		- 克服了一对一模型内核级线程开销太大的缺点

### 进程控制

- 什么叫上下文切换？

	- 上下文，即进程运行环境，包括寄存器、程序计数器等

	- 进程切换即上下文切换

	- 处理机从一个正在运行的进程上切换到另一个进程去执行

- 有哪些进程控制相关原语？

	- 创建原语：create()

	- 阻塞原语：block()

	- 唤醒原语：wakeup()

	- 撤销原语：destroy()

	- 挂起原语：suspend()

	- 激活原语：active()

- 进程的切换流程？

	- 时机

		- ①正在运行的进程运行完毕；

		- ②运行中的进程要求I/O；

		- ③执行某种原语操作；

		- ④一个比正在运行进程优先数更高的进程申请运行（在可剥夺调度方式下）；

		- ⑤分配给运行进程的时间片已经用完等

	- 简述过程

		- （1）记录系统中进程的所有现场信息。

		-  （2）确定分配处理机的原则。 

		- （3）分配处理机给进程。 

		- （4）从进程收回处理机

	- 详细过程

		- 0.检查是否允许上下文切换，有可能某进程处于原语操作中，不允许切换

		- 1.保存当前进程的上下文，包括程序计数器和寄存器

		- 2.更新PCB信息

		- 3.把此进程的PCB移入队列，比如就绪队列，或因某种事件的阻塞队列

		- 4.选择另一个（就绪状态）进程执行，并更新其PCB

		- 5.更新内存管理的数据结构

		- 6.恢复所选进程的上下文，将CPU执行权交给所选进程

- 阻塞和唤醒

	- 引起进程阻塞和唤醒的事件

		- 1) 请求系统服务

			- 等待OS分配打印机服务

		- 2) 启动某种操作

			- 等待I/O操作完成

		- 3) 新数据尚未到达

			- B进程等待A进程的数据输入

		- 4) 无新工作可做

			- 进程空闲，等待新任务到来

	- 进程阻塞过程

		- 调用阻塞原语block()把自己阻塞

			- 进程的阻塞是一种主动行为

		- 1.立即停止执行

		- 2.由执行状态（Running）改为阻塞状态（Blocked）

		- 3.将PCB插入阻塞队列

		- 因不同事件进行阻塞的进程可能会形成多个阻塞队列，直到调度程序进行重新调度它们

	- 进程唤醒过程

		- 有关进程调用唤醒原语wakeup( )， 将等待该事件的进程唤醒

		- 1.把被阻塞的进程从等待该事件的阻塞队列中移出

		- 2.将其PCB中的现行状态改为就绪，再将该PCB插入到就绪队列中

		- 被唤醒的进程进入就绪状态（Ready），而非执行状态（Running）

	- 被阻塞进程必须由其它进程唤醒，否则，将一直处于阻塞状态，从而再无机会继续运行

- 进程挂起

	- 概念

		- 1， 使正在执行的进程暂停执行；

		- 2， 若此时用户进程正处于就绪状态而未执行， 则该进程暂不接受调度， 以便用户研究其执行情况或对程序进行修改

		- 此时，我们把这种静止状态称为挂起状态

	- 挂起的原因

		- (1) 终端用户的请求

			- 发现可疑问题，希望进程静止下来

		- (2) 父进程请求

			- 父进程希望挂起子进程，以便协调各子进程间的活动

		- (3) 负荷调节的需要

			- 负荷较重，挂起不重要的进程

		- (4) 操作系统的需要

			- OS检查资源使用情况，或进行记账

	- 挂起过程

		- 首先检查被挂起进程的状态， 若处于活动就绪状态， 便将其改为静止就绪

		- 对于活动阻塞状态的进程，则将之改为静止阻塞

		- 若被挂起的进程正在执行，则转向调度程序重新调度

		- 把该进程的PCB复制到某指定的内存区域，方便用户或父进程考查该进程的运行情况

	- 进程激活

		- 激活原因

			- 父进程或用户进程请求激活

		- 激活过程

			- 激活原语先将进程从外存调入内存

			- 检查该进程的现行状态，若是静止就绪，便将之改为活动就绪

			- 若为静止阻塞，便将之改为活动阻塞

		- 激活后需要根据处理机调度策略和进程优先级等条件决定该进程是否执行

- 进程终止的方式？

	- 步骤

		- 1.OS将该进程标记为终止

		- 2.资源释放和回收

			- 终止态的进程不能再执行，但会保留一个记录（保存状态码和一些计时统计数据），供其它进程收集

			- 等待操作系统进行善后处理，然后将其PCB清零， 并将PCB空间返还系统，该进程被删除

	- 进入终止的原因

		- 1）正常结束

			- 自然结束：运行到Holt指令（最后一条指令）时，将产生一个中断，去通知OS本进程已经完成

		- 2）异常结束

			- 由于出现某些错误和故障而迫使进程终止

			- 越界错误，

			- 保护错误，

			- 非法指令，

			- 特权指令错误，

			- 运行超时，

			- 等待超时，

			- 算术运算错误，

			- I/O故障

		- 3）外界干预

			- 进程应外界的请求而终止运行

			- 被操作员或操作系统终结

			- 被其他有终止权的进程（父进程）所终结

### 进程调度

- 都有哪些调度场景？

	- 高级调度

		- (High-Level Scheduling)，又叫作业调度

		- 按一定原则从外存处于后备状态的作业中挑选一个（或多个），给它们分配资源（内存、I/O设备等）并建立进程，以使它们获得竞争处理机的权利

		- 把后备作业调入内存运行

		- 只调入一次，调出一次

		- 通俗的说，就是把程序从硬盘加载到内存中运行的过程

	- 中级调度

		- (Intermediate-Level Scheduling)，又叫内存调度，提高内存利用率和系统吞吐量

		- 将暂时不能运行的进程挂起并调至外存（比如硬盘上的虚拟内存）等待，条件合适时再调入内存就绪

		- 在内、外存对换区进行进程对换

	- 低级调度

		- (Low-Level Scheduling)，又叫进程调度

		- 是一种最基本的调度，频率非常高（几十毫秒一次，相当于一个时间片完成）

		- 从就绪队列中选取进程分配给处理机

- 进程调度策略？

	- 剥夺调度方式

		- 抢占式

		- 立即暂停正在执行的进程，将处理机分配给另一个更重要或优先级更高的进程

		- 更高效

		- 原则

			- 优先权

			- 短进程优先

			- 时间片原则

	- 非剥夺调度方式

		- 非抢占式（或协作式）

		- 若有进程请求执行，等待当前正在执行进程完成或因某种原因阻塞，才把处理机分配给请求进程

		- 优点是实现简单，系统开销小（切换频次低了）

		- 缺点是适用批处理系统，不适用大多分时和实时系统

- 进程调度算法？

	-   1. 先来先服务（FCFS）调度算法

		- 适用于作业调度和进程调度

		- 取作业队列中或就绪队列中最先入队的进程进行调度，并等待操作完成，或作业执行完成或因某种原因阻塞时释放处理机

		- FCFS属于不可剥夺算法，简单但效率低，可能导致后续作业长时间得不到执行，不能作为分时和实时系统的主要调度策略

		- 是使用优先级作为调度策略的系统中，相同优先级作业一般按照FCFS原则处理

		- 有利于CPU繁忙型作业，不利于I/O繁忙型作业

	-   2. 短作业优先（SJF）调度算法

		- 短作业调度（SJF）：从后备队列中选择一个或多个估计运行时间最短的作业运行

		- 短进程调度（SPF）：从就绪队列中选择一个或多个估计运行时间最短的进程运行，直到完成或阻塞

		- 缺点

			- 对长作业不利，长作业周转时间会增加，也可能导致长作业长时间不被调度而产生“饥饿”现象

			- 不能保证更紧迫的任务被及时处理

			- 估计执行时间可能不准确

		- 优点

			- SJF调度算法的平均等待时间、平均周转时间最少

	-   3. 优先级调度算法

		- 又叫优先权调度算法

		- 可用于作业调度和进程调度

		- 优先级用于描述作业的紧迫程度

		- 优先级能否改变

			- 静态优先级

				- 创建进程时确定（依据进程类型、对资源的要求、用户要求），运行期保持不变

			- 动态优先级

				- 进程运行期动态调整优先级，主要依据进程占有CPU时间的长短、就绪进程等待CPU时间的长短等因素

		- 非剥夺式调度时，新的更高优先级进程并不能获得及时执行

		- 剥夺式调度时，新的更高优先级进程一旦进入就绪队列，则当前进程立即暂停，并将处理机分配给新进程

	-   4. 高响应比优先调度算法

		- 主要用于作业调度，是对FCFS和SJF的综合平衡

		- 调度时先计算作业的响应比

			- 作业等待时间相同，服务时间越短，响应比越高

				- 有利于短作业

			- 服务时间相同，响应比由等待时间决定，等待越久，响应比越高

				- 先来先服务

			- 长作业的响应比可以随等待时间提高，等待愈久，响应比越高，更容易获得处理机

				- 克服了饥饿状态，兼顾长作业

	-   5. 时间片轮转调度算法

		- 适用于分时系统

		- 将所有就绪进程按照到达顺序入队，并总是选择第一个进程执行（先来先服务），但仅能运行一个时间片（如100ms），时间到，立刻剥夺该进程执行权并重新入队（队尾），处理机取下一个进程运行

		- 时间片大小对OS性能影响很大

			- 时间片太大以至于所有进程都能在（属于自己的）一个时间片内执行完成，则此算法退化为先来先服务调度算法

			- 时间片太小，处理机将不停切换，开销增大

			- 时间片大小因素：系统响应时间，就绪队列进程数目，系统处理能力

	-   6. 多级反馈队列调度算法
（集合前几种的优点）

		- 集合了前几种算法的优点：相当于时间片轮转调度算法 + 优先级调度算法

		- 动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面系统目标

			- 为提高OS吞吐量和缩短平均周转时间而照顾短进程

			- 为获得较好IO设备利用率和缩短响应时间而照顾IO型进程

			- 不必事先估算进程的执行时间

		- 实现思想

			- 1）设置多个就绪队列，为不同队列设置不同的优先级（逐次降低）

			- 2）不同队列中进程时间片不同，优先级高的队列中进程时间片小，反之则长（倍长法）

			- 3）新进程采用队列降级法：进入第1级队列（队尾，遵循FCFS），没有执行完，移到第2级，未完，移到第3级。。。

			- 4）前面队列不为空，不会执行后续队列的进程

		- 优势

			- 1）终端型作业用户：短作业优先

			- 2）短批处理作业用户：周转时间较短

			- 3）长批处理作业用户：经过前面几个队列已经得到部分执行，不会长期得不到处理（饥饿）

- 影响调度程序的指标有什么？

	-   1. CPU利用率

		- 越高，说明该资源使用率越高

	-   2. 系统吞吐量

		- 单位时间内CPU完成作业量

		- 长作业耗时，短作业则能提高吞吐量

		- 调度算法和方式不同，对OS吞吐量产生较大影响

	-   3. 周转时间

		- 作业从提交到完成经历的时间

		- 包括等待、就绪队列的排队，处理机上的运行、输入输出花费时间的总和

	-   4. 等待时间

		- 进程等待时间总和

		- 调度算法不影响作业执行或输入输出时间，只影响作业在就绪队列中等待时间

		- 所以，衡量调度算法的优劣，考察等待时间即可

	-   5. 响应时间

		- 用户提交请求到系统首次响应花费的时间

		- 交互是系统中衡量调度算法的重要准则

		- 应尽量降低响应时间，控制在用户可接受范围内

	- 调度程序一方面要满足特定系统用户的要求（实时和交互进程要求快速响应），另一方面要考虑系统整体效率（减少整个系统进程平均周转时间）和调度算法本身的开销

- 什么是RR调度？Round-Robin

### 进程通信

- 什么叫进程通信？

	- 进程通信即进程间的信息交换

	- IPC（Inter-Process Communication）

- 进程间的通信方式？

	- 1. 共享存储（Shared-memory）

		- (1) 基于共享数据结构的通信方式。 

		- (2) 基于共享存储区的通信方式。 

		- 数据的发送方不关心数据由谁接收，数据的接收方也不关心数据是由谁发送的，存在安全隐患

		- 很容易控制容量，速度快，但要保持同步

	- 2. 消息传递（message-passing）

		- 基本概念

			- 利用OS提供的消息传递方式进行通信

			- 以格式化的消息(message)进行传递

			- 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题

			- 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态

		- 收发操作

			- Send原语

			- Receive原语

		- 两种方式

			- 直接通信

				- 点到点发送

				- 发送和接收时指明双方进程的ID

				- 发送进程直接发消息到接收进程的消息缓冲队列上，
接收进程从自己的消息缓冲队列上读取消息

			- 间接通信

				- 以信箱为媒介进行传递，可以广播

				- 发送进程直接发消息到中间实体（信箱）上，
接收进程从中间实体上读取消息

				- 很容易建立双向通讯链

		- Linux系统中常用信号

			- （1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。

			- （2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。

			- （3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。

			- （4）SIGBUS和SIGSEGV：进程访问非法地址。

			- （5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。

			- （6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。

			- （7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。

			- （8）SIGALRM：定时器信号。

			- （9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程

	- 3. 管道通信（Pipe）

		- 概念

			- 基于文件系统和缓冲思想实现的一种通信方式

			- 管道以先进先出(FIFO)方式组织数据传输

			- 管道是一个单向通信信道，如果进程间要进行双向通信，通常需要定义两个管道

			- 管道通过系统调用read(), write()函数进行读写操作

		- 分类

			- 匿名管道（pipe）

				- 单向

				- 只能亲缘关系进程通信

			- 命名管道（FIFO）

				- 实现方式是文件

				- 可以实现本机任意两个进程通信

		- 速度慢，容量有限；

	- 4.信号量

		- 信号量是一个计数器，可以用来控制多个进程对共享资源的访问

		- 作为一种锁机制，同步手段

		- 不能传递复杂消息，只能用来同步

	- 5.Socket通信

		- 可用于不同机器间的进程通信

		- 任何进程间都能通讯，但速度慢

### 进程同步

- 什么是临界资源？

	- 共享资源一次只能供一个进程使用。一次仅允许一个进程使用的资源称为临界资源

	- 应采取『互斥』方式，实现对临界资源的访问

	- 常见临界资源

		- 输入机、打印机、磁带机

		- 消息缓冲队列、变量、数组、缓冲区

- 什么是临界区？

	- 用于实现进程互斥的那段代码称为临界区

	- 访问过程

		- 1）进入区

			- 进入临界区前检查权限，否则等待/阻塞

			- 设置正在访问临界区的标识

		- 2）临界区

			- 访问临界资源的代码

		- 3）退出区

			- 将正在访问临界区的标识清除

		- 4）剩余区

			- 代码剩余部分

	- 如何解决冲突？

		- 一次仅允许一个进程进入

		- 有限时间内退出

		- 不能进入自己的临界区，则让出CPU

- 临界区访问原则？

	- 0）死等

		- 等待有限时间

		- 时限内没能进入临界区

		- 应该放弃没有希望的等待

	- 1）空闲让进

		- 临界区空闲，可以允许一个进程进入临界区

	- 2）忙则等待

		- 已有进程进入临界区，其它试图进入的进程应等待

		- 一直运行，而非阻塞

		- 应该放弃执行权

	- 3）有限等待

		- 确保等待的进程，进入临界区前的等待时间有限

	- 4）让权等待

		- 不能进入临界区时，应让出CPU执行权，防止忙等待（即占用CPU执行权的等待）

- 什么是监视器？

- 什么是管程？

	- Monitor，即监视器，是一个实体

	- 即用于实现进程同步的工具。是由代表共享资源的数据结构和一组过程（进行PV操作的函数）组成的管理程序

	- 管程的组成

		- 管程名称

		- 局部于管程内部的共享数据结构

		- 对该数据结构操作的一组过程（函数）

		- 管程内共享数据的初始化语句

	- 管程的基本特性

		- 是一个模块化的基本程序单位，可以单独编译

		- 是一种抽象数据类型，包含数据和操作

		- 信息掩蔽，共享数据只能被管程内的过程访问

	- 条件变量/条件对象

		- 进入管程的进程可能由于条件不满足而阻塞

		- 此时进程应释放管程以便其它进程调用管程

		- 进程被阻塞的条件（原因）有多个，移入不同的条件队列

		- 进程被移入条件队列后，应释放管程

- 什么是同步？

	- 基本义：随时间的变化保持一定的相对关系

	- 直接制约关系，比如管道通信方式

- 什么是互斥？

	- 基本义：相互独立、互不干扰的工作

	- 间接制约关系，比如共享资源方式

- 进程同步的方式？

	- 1、临界区：

		- 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问

		- 只能用来同步本进程内的线程，而不可用来同步多个进程中的线程

	- 2、互斥量：

		- 比临界区复杂。互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。

		- 同一进程/不同进程中的不同线程中实现共享

		- 可以跨越进程使用，但相比临界区更占资源

	- 3、信号量：

		- 为控制一个具有有限数量用户资源而设计

		- 允许多个线程（不超过资源可用数量）在同一时刻访问同一资源

		- 最大资源数=1，即互斥量

	- 4、事件： 

		- 用来通知线程有一些事件已发生，从而启动后继任务的开始

		- 事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。

- 经典同步问题？

	- 读者-写者问题

		- 允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生

		- 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁

	- 哲学家进餐问题

		- 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子

		- 必须同时拿起左右两根筷子；

		- 只有在两个邻居都没有进餐的情况下才允许进餐

### 锁与死锁

- 锁

	- 什么是锁？

		- 同步工具

		- 管程（Monitor）

	- 什么是悲观锁、乐观锁？

		- 悲观锁

			- 基于一种悲观的态度类来防止一切数据冲突

			- 在它释放锁之前任何人都不能对其数据进行操作

			- 可以完全保证数据的独占性和正确性

			- 性能不高

		- 乐观锁

			- 对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁

			- 只有到数据提交的时候才通过一种机制来验证数据是否存在冲突

			- 通过加版本号然后进行版本号的对比方式

	- 什么是非公平锁、非公平锁？

		- 公平锁

			- 多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁

			- 优点：所有的线程都能得到资源，不会饿死在队列中。

			- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大

		- 非公平锁

			- 多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁

			- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。

			- 缺点：这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死

	- 什么是CAS？

		- Compare And Swap，比较并交换

		- Compare And Set，比较并赋值

		- 判断内存中某个地址的值是否为预期值，如果是就改变成新值，整个过程具有原子性

		- 底层硬件实现

			- Test-And-Set（TS指令/TSL指令）读出标志并设置为true，返回旧值，原子操作

			- Swap指令（ EXCHANGE，XCHG指令）交换两个变量的值，原子操作

		-  ABA问题

			- 如果内存地址V初次读取的值是A，在CAS等待期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过

			- 使用带版本号的原子引用AtomicStampedRefence<V>，或者叫时间戳的原子引用，类似于乐观锁

	- 什么是自旋锁?

		- 线程A进入临界区失败，不进入阻塞，而是空转，直到该临界区的锁被释放

		- 自旋，本质上就是个死循环：无限尝试加锁

		- 线程A认为锁能在很短时间内释放，没必要进入阻塞，避免了用户线程和内核线程的切换开销

		- 优点：开启自旋锁后能减少线程的阻塞，在对于锁的竞争不激烈且占用锁时间很短的代码块来说，能提升很大的性能，在这种情况下自旋的消耗小于线程阻塞挂起的消耗。

		- 缺点：在线程竞争锁激烈，或持有锁的线程需要长时间执行同步代码块的情况下，使用自旋会使得cpu做的无用功太多。

	- 什么是共享锁/排他锁？

		- 共享锁

			- 又称为读锁，可以查看但无法修改和删除的一种数据锁

			- MySql数据库，一个事务加了共享锁，其它事务也只能加共享锁，直到所有事务释放该数据对象的共享锁

		- 排他锁

			- 又称为写锁、独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁

	- 锁的状态有哪些（Java）？

		- 什么是无锁？

			- 锁标志位 01

			- 是否偏向锁 0

		- 什么是偏向锁？

			- 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁

			- 对象的锁偏向某个线程

				- 某个线程获得锁，当该线程下次再想要获得锁时，不需要再获得锁（即忽略synchronized关键词），直接就可以执行同步代码

				- 适合竞争较少的情况

			- 加锁过程

				-  （1）查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态。

					- 锁标志位代表了当前对象内置锁的状态

				-  （2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，若相同，则直接执行同步代码，否则进入下一步。

				-  （3）当前线程通过CAS操作竞争锁，若竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行同步代码，若竞争失败，进入下一步。

				-  （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。当到达全局安全点时之前获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码

			- 释放过程

				- 线程不会主动去释放偏向锁

				- 偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁状态的线程才会释放锁

				- 偏向锁的撤销需要等待全局安全点（即没有字节码正在执行），它会暂停拥有偏向锁的线程

				- 撤销后偏向锁恢复到未锁定状态或轻量级锁状态。

			- 总结

				- 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的这个线程的ID

				- 以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁

					- 测试成功，表示线程已经获得了锁

					- 测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

		- 什么是轻量级锁？

			- 轻量级锁不是用来替代传统的重量级锁的

			- 减少无实际激烈线程竞争情况下，使用重量级锁产生的性能消耗

			- 包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等

			- 当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁

			- 加锁过程

				- （1）当线程执行代码进入同步块时，若Mark Word为无锁状态，虚拟机先在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储当前对象的Mark Word的拷贝

				- （2）复制对象头中的Mark Word到锁记录中

				- （3）复制成功后，虚拟机将用CAS操作将对象的Mark Word更新为执行Lock  Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行4，否则执行5。；

				- （4）如果更新成功，则这个线程拥有了这个锁，并将锁标志设为00，表示处于轻量级锁状态

				- （5）如果更新失败，虚拟机会检查对象的Mark Word是否指向当前线程的栈帧

					- 是则说明当前线程已经拥有这个锁，可进入执行同步代码

					- 否则说明多个线程竞争，轻量级锁就会膨胀为重量级锁，Mark Word中存储重量级锁（互斥锁）的指针，后面等待锁的线程也要进入阻塞状态

		- 什么是重量级锁？

			- 当有其他线程占用锁时，当前线程会进入阻塞状态

			- Synchronized

			- ReentrantLock

		- 什么是锁升级、降级，锁膨胀？

- 死锁

	- 什么是死锁？

		- 多个进程由于竞争资源而造成的阻塞现象，若无外力作用，这些进程将无法继续推进。

		- 无限阻塞，或互相等待的情况

	- 死锁产生的原因？

		- 系统资源的竞争

		- 进程推进顺序非法

	- 死锁产生的必要条件？

		- 互斥条件

			- 一个资源一次只能被一个进程使用

		- 不剥夺条件

			- 进程获得的资源，在未完全使用完之前，不能强行剥夺

		- 请求并保持条件

			- 一个进程因请求资源而阻塞时，对已获得资源保持不放

		- 循环等待条件

			- 若干进程之间形成一种头尾相接的环形等待资源关系

	- 死锁有哪些类型？

		- 资源死锁

		- 通信死锁

			- 超时重试

		- 什么是活锁？

			- 狭路相逢，礼为先

			- 一般发生在需要持有多个锁的场景

			- 尝试获取锁失败，释放已持有的锁，重试

			- 两个进程/线程都没有阻塞，但同时无法前进

			- 每个线程随机休眠，错开拿锁的时间

		- 什么是饥饿？

			- 长时间获取不到资源，进程的推进被反复推迟

	- 如何破坏/预防死锁？

		-   1. 破坏互斥条件

		-   2. 破坏不剥夺条件

		-   3. 破坏请求和保持条件

		-   4. 破坏循环等待条件

	- 如何避免死锁？

		-   1. 系统安全状态

			- 如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的

			- 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比

		-   2. 银行家算法

			- 单个资源银行家

				- 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配

			-  多个资源银行家

				- 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

				- 检查一个状态是否安全的算法

					- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。

					- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。

					- 重复以上两步，直到所有进程都标记为终止，则状态时安全的

				- 如果一个状态不是安全的，需要拒绝进入这个状态。

	- 怎么检测死锁？

		-   1. 资源分配图（G=(N, E)）

			- 两种资源

			- 两种节点

		-   2. 死锁定理

			- 死锁状态的充分条件

			- 当且仅当此状态下资源分配图是不可完全简化的

			- 简化过程类似于“拓扑排序”算法

	- 死锁的恢复/解除？

		- 资源剥夺

			- 挂起死锁进程

			- 剥夺其资源

			- 将资源分配给其它（死锁）进程

			- 简单粗暴，但不可取

		- 进程回退

			- 回退到足以避免死锁的地步

			- 需要记录进程历史信息，设置还原点（监测点）

			- 保存存储映像、资源状态

		- 撤销进程

			- 杀死进程恢复

