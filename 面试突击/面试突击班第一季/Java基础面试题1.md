# 技术面试中的几个注意点:

1.**面试时,你熟悉的问题要和面试官多聊,不要为了回答问题而回答问题**

**2 .一个问题的沟通时间最好能多聊一会儿**,简单问题说3-**5**分钟,如果问题的规模比较大,**10分钟左右也是可以的**

3.回答问题时不要为了凑时间而凑时间,聊的内容一定要和问的问题相关,知识点可以连续的引入

4.了解的东西多聊,不了解的少说

5.对于知识可以有一些自己的见解,自己的想法,清晰表述出来,虽然自己的看法有时候不会特别的恰当.

**6. 面试时收集面试录音**,面试题

7.**答题思路** 总——**分——** **总**    点线面

# 请聊一下**java的集合类，以及在实际项目中你是如何用的？**

参照**java集合一章**

注意说出集合体系,常用类 **接口** 实现类

加上你所知道的高并发集合类,JUC     参照集合增强内容

在实际项目中引用,照实说就好了

问集合的引子… …

# Hashmap为什么要使用红黑树？

在jdk1.8版本后，java对HashMap做了改进，在链表长度大于8的时候，将后面的数据存在红黑树中，以加快检索速度

红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。加快检索速率。

# 集合类是怎么解决高并发中的问题？

思路 ：先说一下那些是非安全、普通的安全的集合类、JUC中高并发的集合类

线程非安全的集合类 ArrayList LinkedList HashSet TreeSet HashMap TreeMap 实际开发中我们自己用这样的集合最多,因为一般我们自己写的业务代码中,不太涉及到多线程共享同一个集合的问题

线程安全的集合类 Vector HashTable 虽然效率没有JUC中的高性能集合高,但是也能够适应大部分环境

高性能线程安全的集合类

·  1.ConcurrentHashMap

·  2.ConcurrentHashMap和HashTable的区别

·  3.ConcurrentHashMap线程安全的具体实现方式/底层具体实现

·  4.说说CopyOnWriteArrayList

ConcurrentHashMap

java5.0在juc包中提供了大量支持并发的容器类，采用“锁分段”机制，Concurrentlevel分段级别，默认16，就是有16个段（segment)，每个段默认又有16个哈希表（table），每个又有链表连着。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/58551/1752150920003/9c68776f70bd457eaa41e4b7f47dbdd8.png)

在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争。
JDK1.8ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）
synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。

ConcurrentSkipListMap是 **线程安全的有序的哈希表**(相当于线程安全的TreeMap) ; 它 **继承于**AbstractMap类，并且实现ConcurrentNavigableMap接口。ConcurrentSkipListMap是 **通过“跳表”来实现的** ，

ConcurrentSkipListSet是 **线程安全的有序的集合**(相当于线程安全的TreeSet) ； **它继承于**AbstractSet，并实现了NavigableSet接口 。ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它也支持并发。

CopyOnWriteArraySet addIfAbsent和 CopyOnWriteArrayList（写入并复制）也是juc里面的，它解决了并发修改异常，每当有写入的时候，就在底层重新复制一个新容器写入，最后把新容器的引用地址赋给旧的容器，在别人写入的时候，其他线程读数据，依然是旧容器的线程。这样是开销很大的，所以不适合频繁写入的操作。适合并发迭代操作多的场景。只能保证数据的最终一致性

# 简述一下自定义异常的应用场景？

借助异常机制,我们可以省略很多业务逻辑上的判断处理,直接借助java的异常机制可以简化业务逻辑判断代码的编写

1当你不想把你的错误直接暴露给前端或者你想让前端从业务角度判断后台的异常，这个时候自定义异常类是你的不二选择

2 虽然JAVA给我们提供了丰富的异常类型,但是在实际的业务上,还有很多情况JAVA提供的异常类型不能准确的表述出我们业务上的含义

3 控制项目的后期服务 … …

# 描述一下**Object类中常用的方法？**

参照面向对象章节toString hashCode equals clone finalized wait notify notifyAll … …

解释每个方法的作用

toString 定义一个对象的字符串表现形式  Object类中定义的规则是 类的全路径名+@+对象的哈希码 重写之后我们可以自行决定返回的字符串中包含对象的那些属性信息…

clone >>>返回一个对象的副本  深克隆 浅克隆原型模式重写时实现Cloneable

finalized GC 会调动该方法 自救

# 1.8的新特性有了解过吗？(注意了解其他版本新特征) +JDK更新认识

· **Lambda表达式**

· **函数式接口**  函数式编程

· **方法引用和构造器调用**

· **Stream API**

· **接口中的默认方法和静态方法**

· **新时间日期API**

新的日期类

| **属性**          | **含义**                                                          |
| ----------------------- | ----------------------------------------------------------------------- |
| **Instant**       | 代表的是时间戳                                                          |
| **LocalDate**     | 代表日期，比如2020-01-14                                                |
| **LocalTime**     | 代表时刻，比如12:59:59                                                  |
| **LocalDateTime** | 代表具体时间2020-01-12 12:22:26                                         |
| **ZonedDateTime** | 代表一个包含时区的完整的日期时间，偏移量是以UTC/  格林威治时间为基准的 |
| **Period**        | 代表时间段                                                              |
| **ZoneOffset**    | 代表时区偏移量，比如：+8:00                                             |
| **Clock**         | 代表时钟，比如获取目前美国纽约的时间                                    |
